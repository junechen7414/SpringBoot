- Entity: 負責資料持久化，映射類別和資料表

  - `@GeneratedValue` 標示這個欄位的值將會自動產生。Type:
    - IDENTITY: 自動遞增
    - SEQUENCE: 使用序列，但要先定義序列@SequenceGenerator 註解
      - 使用 Sequence 生成主鍵時，allocationSize 這個參數就是用來與資料庫序列的 INCREMENT BY 和 CACHE 設定協同工作的。allocationSize 和 INCREMENT BY 必須具有相同的值。數字越大，減少的資料庫來回行程就越多。
        Cache 是資料庫效能最佳化的功能，並非所有資料庫類型都支援。
      - `allocationSize`:為了盡量減少與資料庫伺服器之間的來回行程 (round trips)，ID 會被分批分配。指定每次分配的 ID 數量。在給定的分配中，有可能某些 ID 不會被使用。因此，這種策略不保證序列值之間沒有空隙 (gaps)。
        預設值是 50。
      - `INCREMENT BY`:指定序列號之間的間隔。這個整數值可以是任何正數或負數，但不能是 0。如果這個值是負數，則序列會遞減。如果這個值是正數，則序列會遞增。
        預設為 1。
      - `CACHE`:指定資料庫預先分配並保留在記憶體中以加快存取速度的序列值數量。如果發生系統故障，所有尚未在已提交的 DML 語句中使用的快取序列值將會遺失。可能遺失的值數量等於 CACHE 參數的值。
      - allocationSize 和資料庫序列的 INCREMENT BY 不一致，可能會導致以下問題：
        - ID 跳號嚴重或重複 (在高併發下可能發生重複)：如果 allocationSize 大於 INCREMENT BY，JPA 會一次從資料庫取走一批 ID，但資料庫序列只按 INCREMENT BY 增加，可能導致部分 ID 未被 JPA 使用就跳過。
        - 效能不佳：如果 allocationSize 小於 INCREMENT BY，JPA 需要更頻繁地向資料庫請求 ID。
    - TABLE: 使用一個 data table 來儲存和查找後產生下個值
    - AUTO: 由 JPA 的實作廠商 (例如 Hibernate) 自動選擇最適合的策略，預設值，或是由其他廠商如 EclipseLink、OpenJPA 的 AUTO 規則
    - UUID: 為新資料自動產生 UUID 依照時間空間去設定
  - `Column`:指定 Entity 屬性對應的資料庫欄位資訊
    - name: 對應資料庫的欄位名稱。
    - columnDefinition:指定資料庫欄位的精確定義，用來確保 JPA 生成的 DDL 符合預期
    - nullable = true:可為空
  - Spring Data JPA 的 Auditing（稽核） 功能分類。幫助追蹤實體的建立者、建立時間、修改者和修改時間等資訊，依賴於 JPA 的實體事件監聽器（Entity Listeners）機制來實現。`@EnableJpaAuditing`常添加在主應用程式類別或是一個獨立的配置類別上，之後在 Entity 類別中使用 `@EntityListeners(AuditingEntityListener.class)` 告訴 JPA Provider 如 Hibernate 要監聽這個 class

    - `@Created`系列: 在實體第一次持久化時設置
    - `@CreateDate`:建立日期
    - `@CreatedBy`:建立者
    - `@LastModified`系列: Spring Data JPA 審計機制會把新增也當成一種修改(修改資料庫狀態)
    - `@LastModifiedDate`:最後修改日期
    - `@LastModifiedBy`:最後修改者
    - `@Temporal(TemporalType.型態)`:指定一個日期時間欄位在對應到資料庫時，應該使用的資料類型。
      - TemporalType.TIMESTAMP
      - TemporalType.DATE
      - TemporalType.TIME
  - JPA Entity生命週期事件Persist/Update/Remove 前後的行為
    - PrePersist/PostPersist: Entity被持久化(新增)前後的事件。
    - PreUpdate/PostUpdate: Entity被更新(修改)前後的事件。
    - PreRemove/PostRemove: Entity被刪除前後的事件。
  - 資料型態 BigDecimal:精確無誤表示任意大小和精度的十進位數字。比起 float/double 有限精確度，但是計算方式是用方法，效能會比+-\*/慢。
  - 建立索引

    - `@Id`標示 Entity 的主鍵，資料庫會自動為主鍵建立一個唯一索引，確保資料的唯一性。
    - `@Table(indexes = {})`:建立索引(可自訂)，方式如下

    ```
    @Table(
        name = "your_entity_name",
        indexes = {
            // 定義一個複合索引，包含欄位 col1 和 col2
            @Index(name = "idx_col1_col2", columnList = "col1, col2"),

            // 定義另一個唯一的複合索引，包含欄位 col3 和 col4
            @Index(name = "uk_col3_col4", columnList = "col3, col4", unique = true)
        }
    )
    ```

    - 關係
      - `@OneToMany`:一個 Entity 可以與多個另一個 Entity 相關聯。例如:一個帳號可以有多筆訂單；在「一」的那一方 (帳號) 使用 `@OneToMany`。
        - `@OneToMany(mappedBy = "值是對方指向自己的屬性名稱")`:告訴 JPA 這個關聯是由「多」的那一方 Entity (訂單) 的哪個屬性來維護的。
        - `@OneToMany(cascade = "CascadeType.策略")`:定義對「一」的這一端(帳號)執行操作時，是否自動應用到「多」的這一端 (訂單)。
          - `CascadeType.PERSIST`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.PERSIST，當您儲存一個新的 Order 時，所有與之關聯的新 OrderDetail 也會被自動儲存。
          - `CascadeType.MERGE`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.MERGE，當您更新一個 Order 時，所有與之關聯的 OrderDetail 也會被自動更新。
          - `CascadeType.REMOVE`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.REMOVE，當您刪除一個 Order 時，所有與之關聯的 OrderDetail 也會被自動刪除。
          - `CascadeType.REFRESH`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.REFRESH，當您刷新一個 Order 時，所有與之關聯的 OrderDetail 也會被自動刷新。
          - `CascadeType.DETACH`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.DETACH，當您關閉一個 Order 時，所有與之關聯的 OrderDetail 也會被自動關閉。
          - `CascadeType.ALL`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.All，通常包含 PERSIST、MERGE、REMOVE、REFRESH 和 DETACH。
        - `@OneToMany(orphanRemoval = "boolean")`:預設為 false。 如果 Entity B 必須依附於 Entity A 才能存在，且當它不再依附於 Entity A 時就應該消失，那麼 Entity A 是父，Entity B 是子；例如:帳戶 (Account) 是父實體 (Parent Entity)，訂單 (Order) 是子實體 (Child Entity)，(訂單不再依附於帳戶時就應該消失)。若一筆訂單不再關聯到任何一個帳號，即成為孤兒。
      - `@ManyToOne`:多個 Entity 連結到一個另一個 Entity。例如:多筆訂單屬於一個帳號，放在「多」的那一方 (訂單)，`@JoinColumn` 通常會放在 `@ManyToOne` 這一側，用來指定外鍵欄位。
        - `@ManyToOne(fetch = "FetchType.策略"))`:控制關聯的單個 Entity (帳號) 何時從資料庫載入。
          - `FetchType.EAGER` (ManyToOne 預設): 立即載入。
          - `FetchType.LAZY`: 延遲載入。
        - `@ManyToOne(cascade = "CascadeType.策略")`:定義對「多」的這一端(訂單)執行操作時，是否自動應用到「一」的這一端 (帳號)。通常設定 `PERSIST` 較常見，較少設定 `REMOVE` 以免誤刪。
        - `@JoinColumn`屬性:
          - name: 資料庫中實際的外鍵欄位名稱。
          - referencedColumnName: 外鍵參考的目標表格 (「一」的那一方) 的主鍵欄位名稱。
      - `@ManyToMany`:多個 Entity 可以與多個另一個 Entity 關聯。例如:多個學生可以參加多門課程，同時一門課程也可以有多個學生。這通常需要在資料庫中建立一個中間表格 (關聯表格) 來維護這種關係，在兩邊的 Entity 類別中都使用 `@ManyToMany`。
      - `@OneToOne`:一個 Entity 只與一個另一個 Entity 相關聯。例如:一個使用者可能只有一個個人資料，vise versa，兩邊的 Entity 類別中都使用 `@OneToOne`。

  -

- Repository : 處理資料的存取邏輯，負責和資料來源互動

  - JpaRepository<Type, Type> 需要指定 Entity 類別 T 和該 Entity 的主鍵類型 ID。基本資料型態如 int 要使用 Integer，int 和 Integer 差在一個是包裝類別，有些方法可以使用，但也因此效率會比 int 差，且 int 不能為 null，可以避免 NullPointerException 的情況，另一方面 Integer 可以為 null，表示沒有值的狀態；java 會自動進行兩者間的轉換。
  - `save()` 方法可以自動判斷 Entity 是否存在，若存在則更新，不存在則新增。若是新增且有`@GeneratedValue`設定的情況下會自動產生值。

- Controller : 接收請求、返回回應

  - ResponseEntity<Type>
    - ResponseEntity 為 Spring 提供的類別用於代表完整的 HTTP 回應(Status code,Header,Body)，其中只有 Status code 必填，Header 可設定，Body 非必填。
    - <>是可以裝所有類型的語法
    - status() 或是 ok() 、 created() ......等等方法會回傳 ResponseEntity.BodyBuilder 的物件，可以設定 Header 或 Body 之後形成 ResponseEntity 物件。如果要回傳 ResponseEntity<Void> 可以用 ResponseEntity.noContent().build()，把 build 留空。

- Service: 處理業務邏輯

- Controller -> Service -> Repository -> Entity。架構的好處包含耦合性鬆親身經歷如移除Entity欄位後VScode的靜態檢核Service出錯，但Controller沒有出錯。

- DTO：在不同層（如 Controller 和 Service）或系統之間（如 API 客戶端和伺服器）傳輸資料的物件。

  - 用途：
    - 隱藏內部領域模型（如 Entity）的細節，避免直接暴露資料庫結構。
    - 根據特定 API 或視圖的需求，組合或篩選來自多個 Entity 的資料。
    - 作為 API 的請求（Request Body）和回應（Response Body）的資料結構。
    - 可以包含針對 API 輸入的驗證邏輯（例如使用 `@NotNull`, `@Size` 等註解）。
  - 與 Entity 的區別：Entity 通常直接映射到資料庫表格，包含持久化相關的邏輯和註解；DTO
  - 不一定要有 setter，應該多數情況是用建構子來建立，之後較不會更動值。

- WebClient: 經由HTTP請求與回應透過端點進行模組/服務間溝通，有助於模組化和把服務個別獨立，
  - 常見方法:
    - `get() / post() / put() / delete()`
    - `uri()`: 設定 URI
    - `bodyValue()`: 傳送 Body 資料(如 POST、PUT)
    - `retrieve()`：啟動請求
    - `bodyToMono(...) / bodyToFlux(...)`：將回應轉為對應物件
  - Mono/Flux():
    - Mono: 回傳空或單個
    - Flux: 回傳空或多個
  - ParameterizedTypeReference: 在執行時期保留泛型類型資訊，不然有些情況靜態的code會報錯說沒辦法識別類型資訊，如webclient的bodyToMono()。

- 實務情形:
  - 普遍使用DTO，保護Entity欄位可以選擇要暴露哪些，且不用DTO的話耦合度高，Entity如果要修改欄位會牽一髮動全身；有DTO的話Entity有欄位要異動，可以去改有被影響的DTO。
  - 只要是總計相關的金額數字，實務上都是當下查詢去做計算出來，因為他的計算所需的元素(EX：單價、利率)可能會隨時變動，資料表基本上都是存計算所需的元素為主。
  - 實務上較不會加上FK是因為會造成資料連動關係，對於資料日後操作有較大影響；例如：刪除資料情況，針對主檔的某筆資料，若它底下有對應關聯的交易檔紀錄，無法直接刪除，因為有關聯關係存在，你必須要先去清除底下有對應關聯的交易檔紀錄，才能完成整個刪除處理，否則，資料庫不允許刪除。

- Other

  - Request Validation: 接收到的請求資料（例如：表單提交、JSON 請求體、URL 參數等）需要經過驗證，以確保資料的格式、內容符合預期和業務邏輯。 - `@Valid`可以啟用驗證，一般加在 Controller 因為是負責接收請求，如果在 @Valid 或 @Validated 的參數後面沒有加上 BindingResult，當驗證失敗時，Spring Boot 預設會拋出 MethodArgumentNotValidException 異常。 
    - 常見的 Validation 註解:
      - @NotNull: 被註解的元素必須不為 null。
      - @NotEmpty: 被註解的元素必須不為 null 且 size > 0 (用於集合、陣列、字串)。
      - @NotBlank: 被註解的字串必須不為 null，且長度必須大於 0 (即不能只有空白字元)。
      - @Size(min=x, max=y): 被註解的元素大小或長度必須在指定的範圍內。
      - @Min/Max(value=x): 被註解的數值必須大於等於指定的值。
      - @DecimalMin/Max(value=x): 被註解的數值必須小於等於指定的小數值。

    - message: 錯誤時顯示的訊息，ex: @NotNull(message = "必須不為 null")
    - 巢狀`@Valid`: 如
            ```class A{  
              @NotNull  
              Integer i;  
              @Valid  
              B b;  
            } ```     
          

  - 四大 HTTP METHOD 支援的 CRUD；參數傳送類型
    - GET: R；通常不支援 RequestBody，
      - PathVariable 識別要取得的特定資源使用
      - RequestParam 提供過濾、分頁、排序等額外條件，在 URL 後面如/getProduct?page=1。
    - POST: ALL；都支援但大多用 RequetBody
    - PUT: C/U；都支援但大多用 RequetBody
    - DELETE: D；通常不支援 RequestBody，大多用 PathVariable
  - Optional.map():Optional 裡面有值，就對這個值進行轉換，並把轉換後的結果包裝在一個新的 Optional 中回傳
  - lombok: 簡化 getter、setter、建構子、toString()......等方法的定義
    - `@Data`: 包含 `@Getter`, `@Setter`, `@RequiredArgsConstructor`, `@ToString`, `@EqualsAndHashCode` 等功能
    - 建構子:會依照宣告欄位的順序來決定建構子參數的順序
      - NoArgsConstructor:預設無參數建構子
      - AllArgsConstructor:全參數建構子
      - RequiredArgsConstructor:包含所有被標記為 final 或帶有 @NonNull 註解的欄位的建構子。
  - Map<keyType,valueType>.keySet()，keySet()顧名思義是把 Map 中全部 key 值作為一個 Set，方便遍歷（Iterate）Map 或任何只要獲取所有鍵的列表時使用
    - Set: A 和 B 為集合
      - 聯集: A.addAll(B)
      - 交集: A.retainAll(B)
      - 差集: A.removeAll(B)
      - 是否包含: A.containsAll(B)