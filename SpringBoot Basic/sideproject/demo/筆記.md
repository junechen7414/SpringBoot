- Entity: 負責資料持久化，映射類別和資料表

  - `@GeneratedValue` 標示這個欄位的值將會自動產生。Type:
    - IDENTITY: 自動遞增
    - SEQUENCE: 使用序列，但要先定義序列@SequenceGenerator 註解
      - 使用 Sequence 生成主鍵時，allocationSize 這個參數就是用來與資料庫序列的 INCREMENT BY 和 CACHE 設定協同工作的。allocationSize 和 INCREMENT BY 必須具有相同的值。數字越大，減少的資料庫來回行程就越多。
        Cache 是資料庫效能最佳化的功能，並非所有資料庫類型都支援。
      - `allocationSize`:為了盡量減少與資料庫伺服器之間的來回行程 (round trips)，ID 會被分批分配。指定每次分配的 ID 數量。在給定的分配中，有可能某些 ID 不會被使用。因此，這種策略不保證序列值之間沒有空隙 (gaps)。
        預設值是 50。
      - `INCREMENT BY`:指定序列號之間的間隔。這個整數值可以是任何正數或負數，但不能是 0。如果這個值是負數，則序列會遞減。如果這個值是正數，則序列會遞增。
        預設為 1。
      - `CACHE`:指定資料庫預先分配並保留在記憶體中以加快存取速度的序列值數量。如果發生系統故障，所有尚未在已提交的 DML 語句中使用的快取序列值將會遺失。可能遺失的值數量等於 CACHE 參數的值。
      - allocationSize 和資料庫序列的 INCREMENT BY 不一致，可能會導致以下問題：
        - ID 跳號嚴重或重複 (在高併發下可能發生重複)：如果 allocationSize 大於 INCREMENT BY，JPA 會一次從資料庫取走一批 ID，但資料庫序列只按 INCREMENT BY 增加，可能導致部分 ID 未被 JPA 使用就跳過。
        - 效能不佳：如果 allocationSize 小於 INCREMENT BY，JPA 需要更頻繁地向資料庫請求 ID。
    - TABLE: 使用一個 data table 來儲存和查找後產生下個值
    - AUTO: 由 JPA 的實作廠商 (例如 Hibernate) 自動選擇最適合的策略，預設值，或是由其他廠商如 EclipseLink、OpenJPA 的 AUTO 規則
    - UUID: 為新資料自動產生 UUID 依照時間空間去設定
  - `Column`:指定 Entity 屬性對應的資料庫欄位資訊
    - name: 對應資料庫的欄位名稱。
    - columnDefinition:指定資料庫欄位的精確定義，用來確保 JPA 生成的 DDL 符合預期
    - nullable = true:可為空
  - Spring Data JPA 的 Auditing（稽核） 功能分類。幫助追蹤實體的建立者、建立時間、修改者和修改時間等資訊，依賴於 JPA 的實體事件監聽器（Entity Listeners）機制來實現。`@EnableJpaAuditing`常添加在主應用程式類別或是一個獨立的配置類別上，之後在 Entity 類別中使用 `@EntityListeners(AuditingEntityListener.class)` 告訴 JPA Provider 如 Hibernate 要監聽這個 class

    - `@Created`系列: 在實體第一次持久化時設置
    - `@CreateDate`:建立日期
    - `@CreatedBy`:建立者
    - `@LastModified`系列: Spring Data JPA 審計機制會把新增也當成一種修改(修改資料庫狀態)
    - `@LastModifiedDate`:最後修改日期
    - `@LastModifiedBy`:最後修改者
    - `@Temporal(TemporalType.型態)`:指定一個日期時間欄位在對應到資料庫時，應該使用的資料類型。
      - TemporalType.TIMESTAMP
      - TemporalType.DATE
      - TemporalType.TIME
  - JPA Entity生命週期事件Persist/Update/Remove 前後的行為
    - PrePersist/PostPersist: Entity被持久化(新增)前後的事件。
    - PreUpdate/PostUpdate: Entity被更新(修改)前後的事件。
    - PreRemove/PostRemove: Entity被刪除前後的事件。
  - 資料型態 BigDecimal:精確無誤表示任意大小和精度的十進位數字。比起 float/double 有限精確度，但是計算方式是用方法，效能會比+-\*/慢。
  - 建立索引

    - `@Id`標示 Entity 的主鍵，資料庫會自動為主鍵建立一個唯一索引，確保資料的唯一性。
    - `@Table(indexes = {})`:建立索引(可自訂)，方式如下

    ```
    @Table(
        name = "your_entity_name",
        indexes = {
            // 定義一個複合索引，包含欄位 col1 和 col2
            @Index(name = "idx_col1_col2", columnList = "col1, col2"),

            // 定義另一個唯一的複合索引，包含欄位 col3 和 col4
            @Index(name = "uk_col3_col4", columnList = "col3, col4", unique = true)
        }
    )
    ```

    - 關係
      - `@OneToMany`:一個 Entity 可以與多個另一個 Entity 相關聯。例如:一個帳號可以有多筆訂單；在「一」的那一方 (帳號) 使用 `@OneToMany`。
        - `@OneToMany(mappedBy = "值是對方指向自己的屬性名稱")`:告訴 JPA 這個關聯是由「多」的那一方 Entity (訂單) 的哪個屬性來維護的。
        - `@OneToMany(cascade = "CascadeType.策略")`:定義對「一」的這一端(帳號)執行操作時，是否自動應用到「多」的這一端 (訂單)。
          - `CascadeType.PERSIST`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.PERSIST，當您儲存一個新的 Order 時，所有與之關聯的新 OrderDetail 也會被自動儲存。
          - `CascadeType.MERGE`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.MERGE，當您更新一個 Order 時，所有與之關聯的 OrderDetail 也會被自動更新。
          - `CascadeType.REMOVE`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.REMOVE，當您刪除一個 Order 時，所有與之關聯的 OrderDetail 也會被自動刪除。
          - `CascadeType.REFRESH`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.REFRESH，當您刷新一個 Order 時，所有與之關聯的 OrderDetail 也會被自動刷新。
          - `CascadeType.DETACH`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.DETACH，當您關閉一個 Order 時，所有與之關聯的 OrderDetail 也會被自動關閉。
          - `CascadeType.ALL`:如果一個 Order 實體關聯了多個 OrderDetail 實體，並且設定了 CascadeType.All，通常包含 PERSIST、MERGE、REMOVE、REFRESH 和 DETACH。
        - `@OneToMany(orphanRemoval = "boolean")`:預設為 false。 如果 Entity B 必須依附於 Entity A 才能存在，且當它不再依附於 Entity A 時就應該消失，那麼 Entity A 是父，Entity B 是子；例如:帳戶 (Account) 是父實體 (Parent Entity)，訂單 (Order) 是子實體 (Child Entity)，(訂單不再依附於帳戶時就應該消失)。若一筆訂單不再關聯到任何一個帳號，即成為孤兒。
      - `@ManyToOne`:多個 Entity 連結到一個另一個 Entity。例如:多筆訂單屬於一個帳號，放在「多」的那一方 (訂單)，`@JoinColumn` 通常會放在 `@ManyToOne` 這一側，用來指定外鍵欄位。
        - `@ManyToOne(fetch = "FetchType.策略"))`:控制關聯的單個 Entity (帳號) 何時從資料庫載入。
          - `FetchType.EAGER` (ManyToOne 預設): 立即載入。
          - `FetchType.LAZY`: 延遲載入。
        - `@ManyToOne(cascade = "CascadeType.策略")`:定義對「多」的這一端(訂單)執行操作時，是否自動應用到「一」的這一端 (帳號)。通常設定 `PERSIST` 較常見，較少設定 `REMOVE` 以免誤刪。
        - `@JoinColumn`屬性:
          - name: 資料庫中實際的外鍵欄位名稱。
          - referencedColumnName: 外鍵參考的目標表格 (「一」的那一方) 的主鍵欄位名稱。
      - `@ManyToMany`:多個 Entity 可以與多個另一個 Entity 關聯。例如:多個學生可以參加多門課程，同時一門課程也可以有多個學生。這通常需要在資料庫中建立一個中間表格 (關聯表格) 來維護這種關係，在兩邊的 Entity 類別中都使用 `@ManyToMany`。
      - `@OneToOne`:一個 Entity 只與一個另一個 Entity 相關聯。例如:一個使用者可能只有一個個人資料，vise versa，兩邊的 Entity 類別中都使用 `@OneToOne`。

  -

- Repository : 處理資料的存取邏輯，負責和資料來源互動

  - JpaRepository<Type, Type> 需要指定 Entity 類別 T 和該 Entity 的主鍵類型 ID。基本資料型態如 int 要使用 Integer，int 和 Integer 差在一個是包裝類別，有些方法可以使用，但也因此效率會比 int 差，且 int 不能為 null，可以避免 NullPointerException 的情況，另一方面 Integer 可以為 null，表示沒有值的狀態；java 會自動進行兩者間的轉換。
  - `save()` 方法可以自動判斷 Entity 是否存在，若存在則更新，不存在則新增。若是新增且有`@GeneratedValue`設定的情況下會自動產生值。

- Controller : 接收請求、返回回應

  - ResponseEntity<Type>
    - ResponseEntity 為 Spring 提供的類別用於代表完整的 HTTP 回應(Status code,Header,Body)，其中只有 Status code 必填，Header 可設定，Body 非必填。
    - <>是可以裝所有類型的語法
    - status() 或是 ok() 、 created() ......等等方法會回傳 ResponseEntity.BodyBuilder 的物件，可以設定 Header 或 Body 之後形成 ResponseEntity 物件。如果要回傳 ResponseEntity<Void> 可以用 ResponseEntity.noContent().build()，把 build 留空。

- Service: 處理業務邏輯

- Controller -> Service -> Repository -> Entity。架構的好處包含耦合性鬆親身經歷如移除Entity欄位後VScode的靜態檢核Service出錯，但Controller沒有出錯。

- DTO：在不同層（如 Controller 和 Service）或系統之間（如 API 客戶端和伺服器）傳輸資料的物件。

  - 用途：
    - 隱藏內部領域模型（如 Entity）的細節，避免直接暴露資料庫結構。
    - 根據特定 API 或視圖的需求，組合或篩選來自多個 Entity 的資料。
    - 作為 API 的請求（Request Body）和回應（Response Body）的資料結構。
    - 可以包含針對 API 輸入的驗證邏輯（例如使用 `@NotNull`, `@Size` 等註解）。
  - 與 Entity 的區別：Entity 通常直接映射到資料庫表格，包含持久化相關的邏輯和註解；DTO
  - 不一定要有 setter，應該多數情況是用建構子來建立，之後較不會更動值。
- 模組間溝通approach
  - WebClient: 經由HTTP請求與回應透過端點進行模組/服務間溝通，有助於模組化和把服務個別獨立，
    - 常見方法:
      - `get() / post() / put() / delete()`
      - `uri()`: 設定 URI
      - `bodyValue()`: 傳送 Body 資料(如 POST、PUT)
      - `retrieve()`：啟動請求
      - `bodyToMono(...) / bodyToFlux(...)`：將回應轉為對應物件
    - Mono/Flux():
      - Mono: 回傳空或單個
      - Flux: 回傳空或多個
    - ParameterizedTypeReference: 在執行時期保留泛型類型資訊，不然有些情況靜態的code會報錯說沒辦法識別類型資訊，如WebClient的bodyToMono()。
  - TransactionalEventListener 事件驅動: 定義事件後加入發布事件之後由監聽該事件的監聽器去處理。會比WebClient還要解耦合，舉例更新商品會發出商品被更新的事件，而訂單的Service中監聽這個事件做出對應的處理，但是難度可能比WebClient高。

- @ControllerAdvice: 
  - AOP的一種應用，定義全局性的設定或處理邏輯主要用途有三種： 
    1. 全局例外處理 (@ExceptionHandler): Spring會將所有的Controller，都應用ExceptionHandler，是種AOP
    2. 全局資料綁定 (@InitBinder) 
    3. 全局模型屬性 (@ModelAttribute)
  - ResponseEntityExceptionHandler: Spring MVC 提供的一個便利的基礎類別。它本身已經實作了許多標準例外的處理方法 (例如：處理 HTTP 方法不支援、請求參數缺失、 資料綁定錯誤等等)；之外還可以自訂例外或是override它提供的方法。
  - @ExceptionHandler: 標示為例外處理器，可以括號內傳入類別@ExceptionHandler(NullPointerException.class)指定處理特定類型的例外，當全域中這個例外類型被拋出，當下沒有catch住Spring就會找ControllerAdvice中有沒有ExceptionHandler能處理這個類型的例外。
  - Spring 會自動將捕捉到的例外物件傳遞進來，以@ExceptionHandler(NullPointerException.class)來說就是NullPointerException的物件，可以使用.getMessage()取得錯誤訊息，Spring也會傳入當前的Web請求物件: WebRequest request，其中方法如.getDescription()可以從中獲取請求的相關資訊，包含請求的 URI 路徑和session id。 
  - 標準化API回應資料類別: 將錯誤訊息要顯示的資訊使用類別來傳遞
  - @ResponseStatus: 放在自訂或override的例外類別中，說明如果沒有被任何@ExceptionHandler catch的話預設例外處理機制會回應這個Status code會回應這個Status code 
- RuntimeException:  
  - 繼承RuntimeException的好處是不需要在方法中註記 throws 甚麼例外；並且不強制要求使用 try-catch。
  - 可與ControllerAdvice良好的整合，Spring 的 @ControllerAdvice 機制設計上就是為了方便處理非受檢例外 (當然也能處理受檢例外，但用非受檢例外的場景更常見且能發揮簡化程式碼的優勢)

- 例外情況
  - 找不到資料: 三種資料(訂單、商品、帳戶)找不到的子類別繼承抽象的父類別ResourceNotFoundException，回應404
  - 傳入資料檢核: 由@Valid表示參數要驗證，包括@NotNull、@NotEmpty、@Size...等等，不符回應400
  - 業務邏輯檢核: 使用分門別類的自訂例外:
    - 帳戶若仍有處理中的訂單不可以把其狀態變為"N"，所以不能夠更新狀態為"N"或是停用帳戶
    - 建立訂單時先驗證該訂單的帳戶是否狀態為"Y"，接著檢查要建立的訂單中的明細中商品狀態是否都為可銷售，**全部商品**可銷售才實際檢核商品庫存量是否足夠，如果足夠才更新庫存
    - 更新訂單時先驗證訂單狀態是否為處理中，如果有沒出現在原訂單中的商品表示為新增的商品，如果原訂單中有的商品不在要更新的訂單中了則為移出訂單的商品，若是原訂單和要更新的訂單都有出現則為變更商品數量或是可能沒變化，接著檢查要更新的訂單中的明細中商品狀態是否都為可銷售，**全部商品**可銷售才實際檢核商品庫存量是否足夠，如果足夠才更新庫存
    - 刪除訂單時檢查訂單的狀態是否是處理中，計算回補庫存量後更新，之後將訂單狀態改為取消
    
- 單元測試
  - JUnit: java測試框架之一，提供許多功能，例如:
    - `@Test`:標註為測試案例，JUnit會執行他並回傳結果，有個AAA模式包含
      - Arrange: 設置所有前置條件，初始化物件、when(...).thenReturn(...)也屬於這個範圍
      - Act: 呼叫要測試的單元
      - Assert: 驗證Act的結果，`assertEquals`, `assertTrue`, `assertFalse`, `assertNull`, `assertNotNull`, **`assertThrows`**
      - Verify: 確保服務層的內部邏輯是正確的，它確實是依賴於 Repository 來判斷產品是否存在，而不是使用了錯誤的判斷方式
    - `@BeforeEach`:標註每個@Test執行前都要先執行這個標註的方法，通常用來做測試前的準備工作如初始化物件，搭配上MockitoAnnotations.openMocks(this)，可以在每個@Test執行前初始化Mock物件，若有`@ExtendWith(MockitoExtension.class)`則會產生衝突，可能是互相覆蓋到
  - Mockito: java Mock框架，主要功能是創建、配置和驗證 mock 物件
    - `@ExtendWith()`: JUnit 5 的擴展機制，啟用 Mockito 的功能，並且初始化Mock物件，`@BeforeEach`中若有`MockitoAnnotations.openMocks(this)`，則會產生衝突，可能是互相覆蓋到
    - `@Mock`: 指建立一個假的（或稱為模擬的）物件，用來替代被測試程式碼所依賴的真實物件。隔離被測試的程式，讓測試只關注這個單元的邏輯，而不受其依賴的外部服務、資料庫或其他複雜元件的影響。
    - `@InjectMock`: 將標註@Mock的物件注入到這個物件的對應欄位    
    - `when(...).thenReturn(...)`: 定義當執行某Mock物件的方法時，指定要回傳甚麼值
    - `doThrow().when(...)`: 定義當執行某Mock物件的方法時，指定要拋出甚麼例外，沒有回傳甚麼值
    - `ArgumentCaptor`:使用.capture()方法可以捕捉傳遞給 mock 物件方法的實際參數值，後續對這些參數進行更詳細的 assertions
- 實務情形:
  - 滿必要使用DTO，保護Entity欄位可以選擇要暴露哪些，且不用DTO的話耦合度高，Entity如果要修改欄位會牽一髮動全身；有DTO的話Entity有欄位要異動，可以去改有被影響的DTO，再去改使用的到的部分，不用像是全部傳入要Entity的都去改。
  - 只要是總計相關的金額數字，實務上都是當下查詢去做計算出來，因為他的計算所需的元素(EX：單價、利率)可能會隨時變動，資料表基本上都是存計算所需的元素為主。
  - 實務上較不會加上FK是因為會造成資料連動關係，對於資料日後操作有較大影響；例如：刪除資料情況，針對主檔的某筆資料，若它底下有對應關聯的交易檔紀錄，無法直接刪除，因為有關聯關係存在，你必須要先去清除底下有對應關聯的交易檔紀錄，才能完成整個刪除處理，否則，資料庫不允許刪除。

- Other

  - Request Validation: 接收到的請求資料（例如：表單提交、JSON 請求體、URL 參數等）需要經過驗證，以確保資料的格式、內容符合預期和業務邏輯。 - `@Valid`可以啟用驗證，一般加在 Controller 因為是負責接收請求，如果在 @Valid 或 @Validated 的參數後面沒有加上 BindingResult，當驗證失敗時，Spring Boot 預設會拋出 MethodArgumentNotValidException 異常。 
    - 常見的 Validation 註解:
      - @NotNull: 被註解的元素必須不為 null，size 可以= 0 (用於集合、陣列、字串)。
      - @NotEmpty: 被註解的元素必須不為 null 且 size > 0 (用於集合、陣列、字串)。
      - @NotBlank: 被註解的字串必須不為 null，且長度必須大於 0 (即不能只有空白字元)。
      - @Size(min=x, max=y): 被註解的元素大小或長度必須在指定的範圍內。
      - @Min/Max(value=x): 被註解的數值必須大於等於指定的值。
      - @DecimalMin/Max(value=x): 被註解的數值必須小於等於指定的小數值。

    - message: 錯誤時顯示的訊息，ex: @NotNull(message = "必須不為 null")
    - 巢狀`@Valid`: 如
            ```class A{  
              @NotNull  
              Integer i;  
              @Valid  
              B b;  
            } ```     
          

  - 四大 HTTP METHOD 支援的 CRUD；參數傳送類型
    - GET: R；通常不支援 RequestBody，
      - PathVariable 識別要取得的特定資源使用
      - RequestParam 提供過濾、分頁、排序等額外條件，在 URL 後面如/getProduct?page=1。
    - POST: ALL；都支援但大多用 RequetBody
    - PUT: C/U；都支援但大多用 RequetBody
    - DELETE: D；通常不支援 RequestBody，大多用 PathVariable
  - Optional.map():Optional 裡面有值，就對這個值進行轉換，並把轉換後的結果包裝在一個新的 Optional 中回傳
  - lombok: 簡化 getter、setter、建構子、toString()......等方法的定義
    - `@Data`: 包含 `@Getter`, `@Setter`, `@RequiredArgsConstructor`, `@ToString`, `@EqualsAndHashCode` 等功能
    - 建構子:會依照宣告欄位的順序來決定建構子參數的順序
      - NoArgsConstructor:預設無參數建構子
      - AllArgsConstructor:全參數建構子
      - RequiredArgsConstructor:包含所有被標記為 final 或帶有 @NonNull 註解的欄位的建構子。
  - Map<keyType,valueType>.keySet()，keySet()顧名思義是把 Map 中全部 key 值作為一個 Set，方便遍歷（Iterate）Map 或任何只要獲取所有鍵的列表時使用
    - Set: A 和 B 為集合
      - 聯集: A.addAll(B)
      - 交集: A.retainAll(B)
      - 差集: A.removeAll(B)
      - 是否包含: A.containsAll(B)
  - Swagger版本也就是dependencies中implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.6'要對的上最前面SpringBoot的版本，不然使用ControllerAdvice時會出現錯誤；應該說到那時候才知道錯誤，之前沒啟用ControllerAdvice不會注意到。